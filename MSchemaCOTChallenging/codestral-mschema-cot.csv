Question,hardness,Gold,Prediction_0.1,Prediction_0.5,Prediction_1.0,EX_0.1,EX_0.5,EX_1.0
"What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",challenging,"SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312","SELECT      c1.Segment AS Segment1,     c2.Segment AS Segment2,     AVG(ym1.Consumption) AS AvgConsumption1,     AVG(ym2.Consumption) AS AvgConsumption2,     AVG(ym1.Consumption) - AVG(ym2.Consumption) AS Difference FROM      yearmonth ym1 JOIN      customers c1 ON ym1.CustomerID = c1.CustomerID JOIN      yearmonth ym2 ON ym1.CustomerID = ym2.CustomerID AND ym1.Date BETWEEN '201301' AND '201312' AND c1.Currency = 'CZK' JOIN      customers c2 ON ym2.CustomerID = c2.CustomerID WHERE      ym1.Date BETWEEN '201301' AND '201312' AND c1.Currency = 'CZK' GROUP BY      c1.Segment, c2.Segment HAVING      c1.Segment < c2.Segment ORDER BY      c1.Segment, c2.Segment","SELECT      c1.Segment AS Segment1,     c2.Segment AS Segment2,     AVG(ym1.Consumption * p.Price) - AVG(ym2.Consumption * p.Price) AS DifferenceInAnnualAverage FROM      yearmonth ym1 JOIN      customers c1 ON ym1.CustomerID = c1.CustomerID JOIN      transactions_1k t ON ym1.CustomerID = t.CustomerID JOIN      products p ON t.ProductID = p.ProductID JOIN      yearmonth ym2 ON ym2.CustomerID = c2.CustomerID WHERE      ym1.Date BETWEEN '201301' AND '201312'     AND ym2.Date BETWEEN '201301' AND '201312'     AND c1.Segment <> c2.Segment GROUP BY      c1.Segment, c2.Segment ORDER BY      c1.Segment, c2.Segment","SELECT MIN(TotalConsumption)         FROM (             SELECT SUM(t.Amount * t.Price) AS TotalConsumption             FROM transactions_1k t             JOIN yearmonth ym ON t.Date = ym.Date             JOIN customers cm ON ym.CustomerID = cm.CustomerID             WHERE ym.Date BETWEEN '201301' AND '201312'             AND cm.Currency = 'CZK'             GROUP BY cm.CustomerID, cm.Segment         )         WHERE Segment = c1.Segment",0,0,0
Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.,challenging,"SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )","SELECT      Patient.ID AS PatientID,     (YEAR(CURRENT_DATE) - YEAR(Patient.Birthday)) AS Age FROM      Patient JOIN      Laboratory ON Patient.ID = Laboratory.ID WHERE      Laboratory.ID IN (         SELECT              Laboratory.ID         FROM              Laboratory         GROUP BY              Laboratory.ID         HAVING              COUNT(Laboratory.ID) > 2     )     AND Laboratory.HCT >= 52   Step 4: Query Review - All table/column references verified - Join condition checked: Patient.ID = Laboratory.ID - Aggregation and grouping confirmed: COUNT(Laboratory.ID) > 2 and HCT >= 52 - Validation against requirements: ","SELECT      Patient.ID AS PatientID,     (YEAR(CURRENT_DATE) - YEAR(Patient.Birthday)) AS Age FROM      Patient JOIN      Laboratory ON Patient.ID = Laboratory.ID WHERE      Patient.ID IN (         SELECT              Laboratory.ID         FROM              Laboratory         GROUP BY              Laboratory.ID         HAVING              COUNT(Laboratory.ID) > 2     )     AND Laboratory.HCT >= 52","SELECT      p.ID,      (YEAR(CURRENT_DATE) - YEAR(p.Birthday)) AS age FROM      Patient p JOIN      Laboratory l ON p.ID = l.ID WHERE      (YEAR(CURRENT_DATE) - YEAR(p.Birthday)) > 52 GROUP BY      p.ID HAVING      COUNT(l.ID) > 2",0,0,0
Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.,challenging,"SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100","SELECT e.event_name, e.event_date FROM event e JOIN attendance a ON e.event_id = a.link_to_event JOIN expense ex ON a.link_to_member = ex.link_to_member WHERE ex.expense_description = 'Pizza' AND ex.cost > 50 AND ex.cost < 100","SELECT e.event_name, e.event_date FROM event e JOIN attendance a ON e.event_id = a.link_to_event JOIN expense ex ON a.link_to_member = ex.link_to_member WHERE ex.expense_description = 'Pizza' AND ex.cost > 50 AND ex.cost < 100","SELECT e.event_name, e.event_date FROM event e JOIN attendance a ON e.event_id = a.link_to_event JOIN expense exp ON e.event_id = exp.link_to_event WHERE exp.expense_description = 'Pizza' AND exp.cost > 50 AND exp.cost < 100   ",0,0,0
"What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",challenging,SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1,"SELECT Diagnosis, COUNT(*) AS Diagnosis_Count FROM Patient JOIN Examination ON Patient.ID = Examination.ID WHERE Examination.""Examination Date"" BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY Diagnosis ORDER BY Diagnosis_Count DESC LIMIT 1","SELECT Diagnosis, COUNT(*) AS DiagnosisCount    - FROM Examination    - JOIN Patient ON Examination.ID = Patient.ID    - WHERE Examination.Examination Date BETWEEN '1985-01-01' AND '1995-12-31'    - GROUP BY Diagnosis    - ORDER BY DiagnosisCount DESC    - LIMIT 1","SELECT Diagnosis, COUNT(*) AS Diagnosis_Count    FROM Patient    JOIN Examination ON Patient.ID = Examination.ID    WHERE Examination.""Examination Date"" BETWEEN '1985-01-01' AND '1995-12-31'    GROUP BY Diagnosis    ORDER BY Diagnosis_Count DESC    LIMIT 1",0,0,0
"In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",challenging,SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL,SELECT      SUM(CASE WHEN eye_colour_id = 7 THEN 1 ELSE 0 END) -      SUM(CASE WHEN eye_colour_id = 1 THEN 1 ELSE 0 END) AS eye_colour_difference FROM      superhero WHERE      weight_kg = 0 OR weight_kg IS NULL,Select superheroes with missing weight data    - Count superheroes with blue eyes and no eye color    - Calculate the difference  sql SELECT   (SELECT COUNT(*) FROM superhero WHERE eye_colour_id = 7 AND (weight_kg > 0 OR weight_kg IS NOT NULL)) -   (SELECT COUNT(*) FROM superhero WHERE eye_colour_id = 1 AND (weight_kg > 0 OR weight_kg IS NOT NULL)) AS difference FROM superhero WHERE weight_kg = 0 OR weight_kg IS NULL,SELECT      SUM(CASE WHEN colour.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN colour.id = 1 THEN 1 ELSE 0 END) AS eye_color_difference FROM      superhero WHERE      weight_kg = 0 OR weight_kg IS NULL,1,0,0
Which set is not available outside of the United States and has foil cards with Japanese writing on them? Please include the set ID in your response.,challenging,"SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0",SELECT DISTINCT s.id FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE s.isForeignOnly = 1 AND s.isFoilOnly = 1 AND st.language = 'Japanese',SELECT s.id FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE s.isFoilOnly = 1 AND st.language = 'Japanese' AND s.isForeignOnly = 1,SELECT sets.id FROM sets JOIN set_translations ON sets.code = set_translations.setCode JOIN cards ON sets.code = cards.setCode JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE sets.isForeignOnly = 1 AND sets.isFoilOnly = 1 AND foreign_data.language = 'Japanese' GROUP BY sets.id,0,0,0
List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.,challenging,"SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3","SELECT d.forename, d.surname, AVG(CAST(p.duration AS REAL)) AS avg_duration FROM drivers d JOIN results r ON d.driverId = r.driverId JOIN pitStops p ON r.raceId = p.raceId AND d.driverId = p.driverId WHERE d.nationality = 'German' AND 1980 < YEAR(d.dob) < 1985 GROUP BY d.driverId ORDER BY avg_duration ASC LIMIT 3","SELECT      d.forename,      d.surname,      AVG(CAST(p.duration AS REAL)) AS avg_pitstop_duration FROM      drivers d JOIN      pitStops p ON d.driverId = p.driverId WHERE      d.nationality = 'German' AND      YEAR(d.dob) BETWEEN 1980 AND 1985 GROUP BY      d.driverId ORDER BY      avg_pitstop_duration ASC LIMIT      3","SELECT d.driverId, d.forename, d.surname, AVG(CAST(p.duration AS REAL)) AS avg_duration FROM drivers d JOIN results r ON d.driverId = r.driverId JOIN races ra ON r.raceId = ra.raceId JOIN seasons s ON ra.year = s.year JOIN pitStops p ON r.raceId = p.raceId AND d.driverId = p.driverId WHERE d.nationality = 'German' AND strftime('%Y', d.dob) BETWEEN '1980' AND '1985' GROUP BY d.driverId ORDER BY avg_duration ASC LIMIT 3",0,0,0
What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?,challenging,SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18,SELECT COUNT(*) AS TotalNonCharteredSchools FROM schools JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.County = 'Los Angeles' AND schools.Charter = 0 AND (frpm.`Free Meal Count (K-12)` * 100 / frpm.`Enrollment (K-12)`) < 0.18,SELECT COUNT(*) AS TotalNonCharteredSchools FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.County = 'Los Angeles' AND s.Charter = 0 AND (f.`Free Meal Count (K-12)` * 100 / f.`Enrollment (K-12)`) < 0.18,SELECT COUNT(*) AS TotalNonCharteredSchools FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.Charter = 0 AND f.Enrollment > 0 AND (f.`Free Meal Count (K-12)` * 100 / f.`Enrollment (K-12)`) < 0.18,1,1,0
"Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",challenging,"SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",NULL,"SELECT      c.Segment,     (SUM(y2013.Consumption) - SUM(y2012.Consumption)) / SUM(y2013.Consumption) * 100 AS PercentageIncrease FROM      customers c JOIN      yearmonth y2012 ON c.CustomerID = y2012.CustomerID AND SUBSTR(y2012.Date, 1, 4) = '2012' JOIN      yearmonth y2013 ON c.CustomerID = y2013.CustomerID AND SUBSTR(y2013.Date, 1, 4) = '2013' WHERE      c.Currency = 'EUR' GROUP BY      c.Segment ORDER BY      PercentageIncrease DESC LIMIT 1","SELECT      c.Segment,     SUM(CASE WHEN ym.Date LIKE '2013%' THEN ym.Consumption ELSE 0 END) AS Consumption2013,     SUM(CASE WHEN ym.Date LIKE '2012%' THEN ym.Consumption ELSE 0 END) AS Consumption2012,     ((SUM(CASE WHEN ym.Date LIKE '2013%' THEN ym.Consumption ELSE 0 END) - SUM(CASE WHEN ym.Date LIKE '2012%' THEN ym.Consumption ELSE 0 END)) / SUM(CASE WHEN ym.Date LIKE '2013%' THEN ym.Consumption ELSE 0 END)) * 100 AS PercentageIncrease FROM      yearmonth ym JOIN      customers c ON ym.CustomerID = c.CustomerID WHERE      c.Currency = 'EUR' GROUP BY      c.Segment ORDER BY      PercentageIncrease DESC",0,0,0
Give the full name and contact number of members who had to spend more than average on each expense.,challenging,"SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )","SELECT m.first_name, m.last_name, m.phone FROM member m JOIN (     SELECT e.link_to_member, AVG(e.cost) AS avg_cost     FROM expense e     GROUP BY e.link_to_member     HAVING AVG(e.cost) > (SELECT AVG(cost) FROM expense) ) AS avg_expenses ON m.member_id = avg_expenses.link_to_member","SELECT      m.first_name,      m.last_name,      m.phone FROM      member m JOIN      expense e ON m.member_id = e.link_to_member GROUP BY      m.member_id HAVING      SUM(e.cost) > (SELECT AVG(cost) FROM expense)   ### Step 4: Query Review - **Table/Column References**: All referenced columns (`member`, `expense`) exist in the schema. - **Join Conditions**: Correct join condition applied between `member` and `expense` tables. - **Aggregations and Groupings**: Correct aggregation (`SUM(e.cost)`) and grouping (`GROUP BY m.member_id`) applied. - **Validation**: Ensures members who spent more than the average cost on expenses are selected.  Final SQLite Query: sql SELECT      m.first_name,      m.last_name,      m.phone FROM      member m JOIN      expense e ON m.member_id = e.link_to_member GROUP BY      m.member_id HAVING      SUM(e.cost) > (SELECT AVG(cost) FROM expense) ","SELECT      m.first_name,      m.last_name,      m.phone  FROM      member m JOIN      expense e ON m.member_id = e.link_to_member GROUP BY      m.member_id HAVING      m.member_id IN (         SELECT              e2.link_to_member         FROM              expense e2         GROUP BY              e2.link_to_member         HAVING              e2.cost > AVG(e2.cost)     )   4. **Query Review**:    - ",0,0,0
"Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",challenging,"SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1","SELECT      c.name AS ConstructorName,     c.nationality AS Nationality,     SUM(cs.points) AS TotalPoints FROM      constructorStandings cs JOIN      races r ON cs.raceId = r.raceId JOIN      constructors c ON cs.constructorId = c.constructorId WHERE      r.year BETWEEN 1980 AND 2010     AND r.name = 'Monaco Grand Prix' GROUP BY      cs.constructorId ORDER BY      TotalPoints DESC LIMIT 1","SELECT c.name, c.nationality, SUM(cs.points) AS total_points FROM constructorStandings cs JOIN constructors c ON cs.constructorId = c.constructorId JOIN races r ON cs.raceId = r.raceId WHERE r.name = 'Monaco Grand Prix' AND r.year BETWEEN 1980 AND 2010 GROUP BY cs.constructorId ORDER BY total_points DESC LIMIT 1","SELECT c.name, c.nationality, cs.points FROM constructorStandings cs JOIN constructors c ON cs.constructorId = c.constructorId JOIN races r ON cs.raceId = r.raceId WHERE r.name = 'Monaco Grand Prix' AND r.year BETWEEN 1980 AND 2010 ORDER BY cs.points DESC LIMIT 1",0,0,0
"For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",challenging,SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' ),SELECT (SUM(isNonFoilOnly = 1) / SUM(language = 'Japanese')) * 100 AS percentage    - FROM cards    - JOIN set_translations ON cards.uuid = set_translations.uuid    - JOIN sets ON set_translations.setCode = sets.code    - WHERE isNonFoilOnly = 1 AND language = 'Japanese'  4. Query Review:    - All table/column references are correct    - Join conditions are appropriate    - Calculation is correct    - Query meets requirements  Final SQLite Query: sql SELECT (SUM(isNonFoilOnly = 1) / SUM(language = 'Japanese')) * 100 AS percentage FROM cards JOIN set_translations ON cards.uuid = set_translations.uuid JOIN sets ON set_translations.setCode = sets.code WHERE isNonFoilOnly = 1 AND language = 'Japanese',SELECT      (SUM(cards.isNonFoilOnly = 1) / SUM(cards.language = 'Japanese')) * 100 AS percentage_japanese_non_foil FROM      cards JOIN      set_translations ON cards.uuid = set_translations.uuid WHERE      set_translations.language = 'Japanese',SELECT      (SUM(cards.isNonFoilOnly = 1) / COUNT(*)) * 100 AS percentage_non_foil FROM      sets JOIN      set_translations ON sets.code = set_translations.setCode JOIN      cards ON set_translations.uuid = cards.uuid WHERE      set_translations.language = 'Japanese'   Query Review: - All referenced columns exist in the schema. - Joins are based on the identified relationships. - Filters are applied to get only Japanese cards. - Aggregation calculates the percentage of non-foil cards in the Japanese set.  Final SQLite Query: sql SELECT      (SUM(cards.isNonFoilOnly = 1) / COUNT(*)) * 100 AS percentage_non_foil FROM      sets JOIN      set_translations ON sets.code = set_translations.setCode JOIN      cards ON set_translations.uuid = cards.uuid WHERE      set_translations.language = 'Japanese' ,0,0,0
"Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",challenging,SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1,"SELECT p.Id, SUM(p.ViewCount) AS TotalViews FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder') GROUP BY p.Id ORDER BY TotalViews DESC LIMIT 1","SELECT      p.Id,      p.Title,      SUM(p.ViewCount) AS TotalViews FROM      posts p JOIN      users u ON p.OwnerUserId = u.Id WHERE      u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder') GROUP BY      p.Id ORDER BY      TotalViews DESC LIMIT 1","SELECT      p.Id,     p.Title,     p.ViewCount,     u.DisplayName FROM      posts p JOIN      users u ON p.OwnerUserId = u.Id WHERE      u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder') ORDER BY      p.ViewCount DESC LIMIT 1",0,0,0
What is the percentage of cards whose language is French among the Story Spotlight cards?,challenging,SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1,NULL,SELECT (COUNT(cards.id) WHERE cards.isStorySpotlight = 1 AND foreign_data.language = 'French') / COUNT(cards.id) WHERE cards.isStorySpotlight = 1)*100 AS percentage    - FROM cards    - JOIN foreign_data ON cards.uuid = foreign_data.uuid    - WHERE cards.isStorySpotlight = 1  9. Query Review:    - All table/column references verified.    - Join condition applied correctly.    - Aggregation and grouping applied as required.    - Validation against requirements: ,SELECT    (COUNT(cards.id) FILTER (WHERE cards.isStorySpotlight = 1 AND cards.language = 'French')) * 100.0 /    COUNT(cards.id) FILTER (WHERE cards.isStorySpotlight = 1) AS percentage FROM    cards,0,0,0
Which superhero has the most durability published by Dark Horse Comics?,challenging,SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1,SELECT s.superhero_name FROM superhero s JOIN hero_attribute ha ON s.id = ha.hero_id JOIN attribute a ON ha.attribute_id = a.id JOIN publisher p ON s.publisher_id = p.id WHERE a.attribute_name = 'durability' AND p.publisher_name = 'Dark Horse Comics' ORDER BY ha.attribute_value DESC LIMIT 1,SELECT superhero_name FROM superhero    - JOIN hero_attribute ON superhero.id = hero_attribute.hero_id    - JOIN attribute ON hero_attribute.attribute_id = attribute.id    - JOIN publisher ON superhero.publisher_id = publisher.id    - WHERE attribute.attribute_name = 'durability' AND publisher.publisher_name = 'Dark Horse Comics'    - ORDER BY hero_attribute.attribute_value DESC    - LIMIT 1,SELECT TOP 1 s.superhero_name FROM superhero s JOIN hero_attribute ha ON s.id = ha.hero_id JOIN attribute a ON ha.attribute_id = a.id JOIN publisher p ON s.publisher_id = p.id WHERE a.attribute_name = 'durability' AND p.publisher_name = 'Dark Horse Comics' ORDER BY ha.attribute_value DESC,0,0,0
Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.,challenging,SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id,"SELECT      publisher_name,      COUNT(s.id) AS superhero_count FROM      superhero s JOIN      publisher p ON s.publisher_id = p.id WHERE      publisher_name IN ('DC Comics', 'Marvel Comics') GROUP BY      publisher_name ORDER BY      superhero_count DESC","SELECT      publisher_name,      COUNT(s.id) AS superhero_count FROM      superhero s JOIN      publisher p ON s.publisher_id = p.id WHERE      publisher_name IN ('DC Comics', 'Marvel Comics') GROUP BY      publisher_name ORDER BY      superhero_count DESC","SELECT      (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) AS DC_Count,     (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) AS Marvel_Count,     (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) -      (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) AS Difference FROM superhero LIMIT 1",0,0,0
"List all the elements of the toxicology of the molecule ""TR004"".",challenging,SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004',SELECT a.element FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.molecule_id = 'TR004',SELECT element FROM atom WHERE molecule_id = 'TR004',SELECT element FROM atom WHERE molecule_id = 'TR004',1,1,1
"In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",challenging,SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180,SELECT      (COUNT(DISTINCT s.id) FILTER (WHERE p.publisher_name = 'Marvel Comics') * 100.0 / COUNT(DISTINCT s.id)) AS percentage_published_by_marvel FROM      superhero s JOIN      publisher p ON s.publisher_id = p.id WHERE      s.height_cm BETWEEN 150 AND 180,SELECT      (COUNT(s.id) FILTER (WHERE s.publisher_id = 13) * 100.0 / COUNT(s.id)) AS percentage_published_by_marvel FROM      superhero s WHERE      s.height_cm BETWEEN 150 AND 180,SELECT      (COUNT(s.id) FILTER (WHERE s.publisher_id = 13) * 100.0 / COUNT(s.id)) AS percentage_marvel_comics FROM      superhero s WHERE      s.height_cm BETWEEN 150 AND 180,1,1,1
What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.,challenging,"SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'","SELECT constructors.constructorRef, constructors.url FROM results JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE races.year = 2009 AND races.name = 'Singapore Grand Prix' ORDER BY results.position LIMIT 1","SELECT constructors.constructorRef, constructors.url FROM constructorStandings JOIN races ON constructorStandings.raceId = races.raceId JOIN constructors ON constructorStandings.constructorId = constructors.constructorId WHERE races.name = 'Singapore Grand Prix' AND races.year = 2009 ORDER BY constructorStandings.points DESC LIMIT 1","SELECT c.constructorRef, c.url FROM races r JOIN results res ON r.raceId = res.raceId JOIN constructors c ON res.constructorId = c.constructorId WHERE r.year = 2009 AND r.name = 'Singapore Grand Prix' ORDER BY res.points DESC LIMIT 1",0,0,1
"How many times was the budget in Advertisement for ""Yearly Kickoff"" meeting more than ""October Meeting""?",challenging,SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting',SELECT      COUNT(*) AS times_more_than FROM      budget b1 JOIN      event e1 ON b1.link_to_event = e1.event_id JOIN      budget b2 ON b2.link_to_event = e1.event_id JOIN      event e2 ON b2.link_to_event = e2.event_id WHERE      e1.event_name = 'Yearly Kickoff'      AND e2.event_name = 'October Meeting'      AND b1.category = 'Advertisement'      AND b2.category = 'Advertisement'      AND b1.amount / b2.amount > 1,SELECT      (SELECT SUM(b.amount)       FROM budget b       JOIN event e ON b.link_to_event = e.event_id       WHERE e.event_name = 'Yearly Kickoff' AND b.category = 'Advertisement') /     (SELECT SUM(b.amount)       FROM budget b       JOIN event e ON b.link_to_event = e.event_id       WHERE e.event_name = 'October Meeting' AND b.category = 'Advertisement') AS ratio   4. Query Review:    - All table/column references are correct    - Join conditions are appropriate    - ,SELECT      COUNT(*) AS times_more_than FROM      budget AS b1 JOIN      event AS e1 ON b1.link_to_event = e1.event_id JOIN      budget AS b2 ON e1.event_id = b2.link_to_event JOIN      event AS e2 ON b2.link_to_event = e2.event_id WHERE      e1.event_name = 'Yearly Kickoff'      AND e2.event_name = 'October Meeting'      AND b1.category = 'Advertisement'      AND b2.category = 'Advertisement'      AND b1.amount / b2.amount > 1,0,0,0
"Among the bad superheroes, what is the percentage of female superheroes?",challenging,SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Bad',SELECT      (COUNT(DISTINCT s.id) FILTER (WHERE a.id = 2 AND g.id = 2)) * 100.0 / COUNT(DISTINCT s.id) FILTER (WHERE a.id = 2) AS percentage_female_bad_superheroes FROM      superhero s JOIN      alignment a ON s.alignment_id = a.id JOIN      gender g ON s.gender_id = g.id,SELECT COUNT(DISTINCT superhero.id) AS female_bad_count    - FROM superhero    - JOIN alignment ON superhero.alignment_id = alignment.id    - JOIN gender ON superhero.gender_id = gender.id    - WHERE alignment.id = 2 AND gender.id = 2  4. Query Review:    - All table/column references are correct    - Join conditions are appropriate    - No aggregations or groupings are required    - Query validates against requirements  SQLite Query: sql SELECT COUNT(DISTINCT superhero.id) AS female_bad_count FROM superhero JOIN alignment ON superhero.alignment_id = alignment.id JOIN gender ON superhero.gender_id = gender.id WHERE alignment.id = 2 AND gender.id = 2,SELECT COUNT(*) FROM superhero WHERE alignment_id = 2 AND gender_id = 2) * 100.0 / (SELECT COUNT(*) FROM superhero WHERE alignment_id = 2) AS percentage_female_bad_superheroes FROM   superhero LIMIT 1,1,0,0
"List the football team that has a build up play speed of 31, build up plan dribbling of 53, and build up play passing of 32. Only indicate the short name of the team.",challenging,SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeed = 31 AND t2.buildUpPlayDribbling = 53 AND t2.buildUpPlayPassing = 32,SELECT t.team_short_name FROM Team_Attributes ta JOIN Team t ON ta.team_fifa_api_id = t.team_fifa_api_id WHERE ta.buildUpPlaySpeed = 31 AND ta.buildUpPlayDribbling = 53 AND ta.buildUpPlayPassing = 32,SELECT Team.team_short_name    - FROM Team    - JOIN Team_Attributes ON Team.team_api_id = Team_Attributes.team_api_id    - WHERE Team_Attributes.buildUpPlaySpeed = 31 AND Team_Attributes.buildUpPlayDribbling = 53 AND Team_Attributes.buildUpPlayPassing = 32,SELECT t.team_short_name      FROM Team t      JOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id      WHERE ta.buildUpPlaySpeed = 31      AND ta.buildUpPlayDribbling = 53      AND ta.buildUpPlayPassing = 32,1,0,1
How many elements are contained in bond_id TR001_3_4?,challenging,SELECT COUNT(DISTINCT T1.element) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_3_4',SELECT COUNT(DISTINCT element) AS unique_elements FROM atom JOIN connected ON atom.atom_id = connected.atom_id WHERE connected.bond_id = 'TR001_3_4',SELECT COUNT(DISTINCT element) AS distinct_elements FROM atom JOIN connected ON atom.atom_id = connected.atom_id WHERE connected.bond_id = 'TR001_3_4',SELECT COUNT(DISTINCT element) AS distinct_elements FROM atom JOIN connected ON atom.atom_id = connected.atom_id JOIN bond ON connected.bond_id = bond.bond_id JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE bond.bond_id = 'TR001_3_4',1,1,1
What elements are in a double type bond?,challenging,SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '=',SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '=',SELECT DISTINCT element FROM atom    - JOIN connected ON atom.atom_id = connected.atom_id    - JOIN bond ON connected.bond_id = bond.bond_id    - JOIN atom AS atom_bond ON bond.molecule_id = atom_bond.molecule_id    - WHERE bond.bond_type = '='  Final SQLite Query: sql SELECT DISTINCT atom.element FROM atom JOIN connected ON atom.atom_id = connected.atom_id JOIN bond ON connected.bond_id = bond.bond_id JOIN atom AS atom_bond ON bond.molecule_id = atom_bond.molecule_id WHERE bond.bond_type = '=',"SELECT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '='   Step 4: Query Review - All table/column references are correct. - Join conditions are correct. - Aggregations and groupings are not required. - Validated against requirements, ensuring it retrieves elements involved in double type bonds.  Final SQLite Query: sql SELECT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '='",0,0,0
"Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.",challenging,"SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id","SELECT s.superhero_name, c.colour AS eye_colour, c2.colour AS hair_colour, c3.colour AS skin_colour, p.publisher_name FROM superhero s JOIN colour c ON s.eye_colour_id = c.id JOIN colour c2 ON s.hair_colour_id = c2.id JOIN colour c3 ON s.skin_colour_id = c3.id JOIN publisher p ON s.publisher_id = p.id WHERE s.eye_colour_id = s.hair_colour_id AND s.hair_colour_id = s.skin_colour_id","select superhero_name and publisher_name for the result.  sql SELECT s.superhero_name, p.publisher_name FROM superhero s JOIN colour c_eye ON s.eye_colour_id = c_eye.id JOIN colour c_hair ON s.hair_colour_id = c_hair.id JOIN colour c_skin ON s.skin_colour_id = c_skin.id JOIN publisher p ON s.publisher_id = p.id WHERE c_eye.id = c_hair.id AND c_hair.id = c_skin.id",NULL,0,0,0
List the element and bond type included in the molecule with molecule ID of TR002.,challenging,"SELECT DISTINCT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'","SELECT a.element, b.bond_type FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE a.molecule_id = 'TR002'","SELECT element, bond_type FROM atom, bond, connected WHERE molecule_id = 'TR002'    - Ensure all referenced columns exist in the schema    - Include proper joins based on identified relationships  4. Query Review:    - Table/column references verified    - Join conditions: connected.bond_id=bond.bond_id, connected.atom_id2=atom.atom_id, connected.atom_id=atom.atom_id    - No aggregations or groupings    - Validated against requirements  Query: sql SELECT a.element, b.bond_type FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE a.molecule_id = 'TR002'","SELECT a.element, b.bond_type FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR002'",0,0,0
"Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",challenging,SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics',"SELECT      MULTIPLY(DIVIDE(SUM(CASE WHEN alignment.alignment = 'Good' THEN 1 ELSE 0 END), COUNT(*)), 100.0) AS percentage_of_good_superheroes FROM      superhero JOIN      alignment ON superhero.alignment_id = alignment.id WHERE      publisher.publisher_name = 'Marvel Comics'",SELECT (COUNT(alignment = 'Good' AND publisher_name = 'Marvel Comics') / COUNT(publisher_name = 'Marvel Comics')) * 100.0 AS percentage    - FROM superhero    - JOIN alignment ON superhero.alignment_id = alignment.id    - JOIN publisher ON superhero.publisher_id = publisher.id    - WHERE publisher.publisher_name = 'Marvel Comics',"SELECT      MULTIPLY(DIVIDE(SUM(s.alignment_id = 1), COUNT(s.publisher_id)), 100.0) AS percentage FROM      superhero s JOIN      publisher p ON s.publisher_id = p.id WHERE      p.publisher_name = 'Marvel Comics'",0,0,0
"For all the female patient age 50 and above, who has abnormal red blood cell count. State if they were admitted to hospital.",challenging,"SELECT DISTINCT T1.ID, T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0) AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50","SELECT      Patient.ID,      Patient.Sex,      Patient.Birthday,      Patient.Admission,      Examination.RBC FROM      Patient JOIN      Examination ON Patient.ID = Examination.ID WHERE      Patient.Sex = 'F'      AND (EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM Patient.Birthday)) >= 50     AND (Examination.RBC <= 3.5 OR Examination.RBC >= 6.0)   Step 4: Query Review - All table/column references verified - Join condition checked: Patient.ID = Examination.ID - Aggregations and groupings confirmed - Validated against requirements: ","SELECT      Patient.ID AS PatientID,     Examination.Examination_Date AS ExaminationDate,     Patient.Admission AS Admission FROM      Patient JOIN      Examination ON Patient.ID = Examination.ID WHERE      Patient.Sex = 'F'     AND (EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM Patient.Birthday)) >= 50     AND (Examination.RBC < 3.5 OR Examination.RBC > 6.0) ORDER BY      Patient.ID","SELECT      p.ID AS PatientID,     p.Admission,     l.GOT,     l.GPT,     l.LDH,     l.ALP,     l.TP,     l.ALB,     l.UA,     l.UN,     l.CRE,     l.T_BIL,     l.T_CHO,     l.TG,     l.CPK,     l.GLU,     l.WBC,     l.RBC,     l.HGB,     l.HCT,     l.PLT,     l.PT,     l.APTT,     l.FG,     l.PIC,     l.TAT,     l.TAT2,     l.U_PRO,     l.IGG,     l.IGA,     l.IGM,     l.CRP,     l.RA,     l.RF,     l.C3,     l.C4,     l.RNP,     l.SM,     l.SC170,     l.SSA,     l.SSB,     l.CENTROMEA,     l.DNA,     l.DNA_II,     e.Symptoms FROM      Patient p JOIN      Laboratory l ON p.ID = l.ID JOIN      Examination e ON p.ID = e.ID WHERE      p.SEX = 'F'      AND (l.RBC < 3.5 OR l.RBC > 6.0)      AND (YEAR(CURRENT_TIMESTAMP) - YEAR(p.Birthday)) >= 50     AND p.Admission IN ('+', '-') ORDER BY      p.ID",0,0,0
Which element is the least numerous in non-carcinogenic molecules?,challenging,"SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t","SELECT element, COUNT(*) AS element_count FROM atom JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '-' GROUP BY element ORDER BY element_count ASC LIMIT 1","SELECT a.element, COUNT(a.element) AS element_count FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label = '-' GROUP BY a.element ORDER BY element_count ASC LIMIT 1","SELECT element, COUNT(*) AS element_count FROM atom JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '-' GROUP BY element ORDER BY element_count ASC LIMIT 1",0,0,0
Name chemical elements that form a bond TR001_10_11.,challenging,SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR001_10_11',SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_id = 'TR001_10_11',SELECT DISTINCT element FROM atom    - JOIN connected ON atom.atom_id = connected.atom_id    - JOIN bond ON connected.bond_id = bond.bond_id    - WHERE bond.bond_id = 'TR001_10_11'  4. Query Review:    - All table/column references are correct.    - Join conditions are appropriate.    - No aggregations or groupings.    - Validates against the requirement.  Final Query: sql SELECT DISTINCT atom.element  FROM atom  JOIN connected ON atom.atom_id = connected.atom_id  JOIN bond ON connected.bond_id = bond.bond_id  WHERE bond.bond_id = 'TR001_10_11',SELECT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_id = 'TR001_10_11',1,0,1
"For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",challenging,"SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",SELECT      (COUNT(CASE WHEN PT >= 14 AND SEX = 'F' THEN 1 END) * 100.0 /       COUNT(CASE WHEN PT >= 14 AND SEX = 'F' THEN 1 END)) AS Percentage FROM      Patient p JOIN      Laboratory l ON p.ID = l.ID WHERE      (EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM p.Birthday)) > 55,"SELECT DISTINCT Patient.ID, Patient.SEX, Examination.PT    - FROM Patient    - JOIN Examination ON Patient.ID = Examination.ID    - WHERE SUBTRACT(year(current_timestamp), year(Patient.Birthday)) > 55 AND Patient.SEX = 'F' AND Examination.PT >= 14    - GROUP BY Patient.SEX, Examination.PT    - HAVING COUNT(*) > 0    - ORDER BY Patient.SEX, Examination.PT    - SELECT DIVIDE(SUM(Examination.PT >= 14 AND Patient.SEX = 'F'), SUM(Examination.PT >= 14)) * 100 AS Percentage  4. Query Review:    - All table/column references are correct    - Join condition is valid    - Aggregation and grouping are correctly applied    - Query meets the requirements  SQLite Query: sql SELECT      DIVIDE(SUM(Examination.PT >= 14 AND Patient.SEX = 'F'), SUM(Examination.PT >= 14)) * 100 AS Percentage FROM      Patient JOIN      Examination ON Patient.ID = Examination.ID WHERE      (YEAR(CURRENT_TIMESTAMP) - YEAR(Patient.Birthday)) > 55      AND Patient.SEX = 'F'      AND Examination.PT >= 14",SELECT      (SELECT COUNT(*)       FROM Patient p       JOIN Examination e ON p.ID = e.ID       WHERE (EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM p.Birthday)) > 55       AND e.PT >= 14       AND p.SEX = 'F') * 1.0 /     (SELECT COUNT(*)       FROM Patient p       JOIN Examination e ON p.ID = e.ID       WHERE (EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM p.Birthday)) > 55       AND e.PT >= 14) AS Percentage FROM Patient p LIMIT 1,0,0,0
"Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",challenging,"SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')","SELECT      s.School,      s.DOCType FROM      schools s JOIN      frpm f ON s.CDSCode = f.CDSCode WHERE      s.FundingType = 'Locally funded' ORDER BY      (s.Enrollment (K-12) - s.Enrollment (Ages 5-17)) DESC","SELECT      s.School,      s.DOCType FROM      schools s JOIN      frpm f ON s.CDSCode = f.CDSCode WHERE      s.FundingType = 'Locally funded' ORDER BY      (s.Enrollment (K-12) - s.Enrollment (Ages 5-17)) DESC","SELECT CDSCode     FROM schools     WHERE FundingType = 'Directly funded' ), EnrollmentDifferences AS (     SELECT          s.CDSCode,         s.School,         s.DOCType,         (s.Enrollment - (SELECT Enrollment FROM frpm WHERE frpm.CDSCode = s.CDSCode AND frpm.Educational Option Type = 'Traditional')) AS EnrollmentDifference     FROM schools s     JOIN LocalFundedSchools lfs ON s.CDSCode = lfs.CDSCode ) SELECT      e.School,     e.DOCType FROM EnrollmentDifferences e WHERE e.EnrollmentDifference > (SELECT AVG(EnrollmentDifference) FROM EnrollmentDifferences) ORDER BY e.EnrollmentDifference DESC",0,0,0
Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.,challenging,"WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20","SELECT d.forename, d.surname FROM drivers d JOIN results r ON d.driverId = r.driverId JOIN lapTimes lt ON r.raceId = lt.raceId AND r.driverId = lt.driverId WHERE lt.time = (     SELECT MIN(lt2.time)     FROM lapTimes lt2     JOIN results r2 ON lt2.raceId = r2.raceId AND lt2.driverId = r2.driverId ) LIMIT 1","SELECT d.forename, d.surname FROM lapTimes lt JOIN drivers d ON lt.driverId = d.driverId JOIN races r ON lt.raceId = r.raceId ORDER BY lt.milliseconds ASC LIMIT 1","SELECT d.forename, d.surname FROM drivers d JOIN results r ON d.driverId = r.driverId JOIN lapTimes lt ON r.raceId = lt.raceId AND r.driverId = lt.driverId ORDER BY lt.time ASC LIMIT 1",0,0,0
Who has the highest average finishing rate between the highest and shortest football player?,challenging,"SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1","SELECT      p.player_name,     AVG(pa.finishing) AS avg_finishing_rate FROM      Player p JOIN      Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE      p.height = (SELECT MAX(height) FROM Player) OR     p.height = (SELECT MIN(height) FROM Player) GROUP BY      p.player_name ORDER BY      avg_finishing_rate DESC LIMIT 1","SELECT player_api_id     FROM Player     WHERE height = (SELECT MAX(height) FROM Player)     UNION     SELECT player_api_id     FROM Player     WHERE height = (SELECT MIN(height) FROM Player) ), AverageFinishingRate AS (     SELECT player_api_id, AVG(finishing) AS avg_finishing_rate     FROM Player_Attributes     GROUP BY player_api_id ) SELECT p.player_name, ar.avg_finishing_rate FROM Player p JOIN AverageFinishingRate ar ON p.player_api_id = ar.player_api_id WHERE p.player_api_id IN (SELECT player_api_id FROM HighestAndShortestPlayers) ORDER BY ar.avg_finishing_rate DESC LIMIT 1","SELECT      p.player_name,      AVG(pa.finishing) AS average_finishing_rate FROM      Player p JOIN      Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE      p.height IN (         SELECT              MAX(height)          FROM              Player         UNION         SELECT              MIN(height)          FROM              Player     ) GROUP BY      p.player_api_id ORDER BY      average_finishing_rate DESC LIMIT 1",0,0,0
"Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",challenging,SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1,SELECT s.id FROM sets s JOIN (     SELECT setCode     FROM sets     WHERE type = 'commander' ) AS commander_sets ON s.code = commander_sets.setCode ORDER BY s.totalSetSize DESC LIMIT 1,NULL,"SELECT      sets.id,      sets.totalSetSize FROM      sets WHERE      sets.type = 'commander' ORDER BY      sets.totalSetSize DESC LIMIT 1",0,0,0
Name the atoms' elements that form bond TR000_2_3.,challenging,SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3',SELECT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id WHERE c.bond_id = 'TR000_2_3',NULL,SELECT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id WHERE c.bond_id = 'TR000_2_3',1,0,1
What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?,challenging,"SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'","SELECT      (SUM(l1997.amount) - SUM(l1996.amount)) / SUM(l1996.amount) * 100 AS growth_rate FROM      loan l1997 JOIN      client c ON l1997.account_id = c.client_id LEFT JOIN      loan l1996 ON l1997.account_id = l1996.account_id AND strftime('%Y', l1996.date) = '1996' WHERE      strftime('%Y', l1997.date) = '1997' AND c.gender = 'M'",SELECT      ((SUM(l1997.amount) - SUM(l1996.amount)) / SUM(l1996.amount)) * 100 AS growth_rate FROM      (SELECT amount       FROM loan       WHERE date >= '1996-01-01' AND date < '1997-01-01') AS l1996 JOIN      (SELECT amount       FROM loan       WHERE date >= '1997-01-01' AND date < '1998-01-01') AS l1997 ON      l1996.amount = l1997.amount JOIN      client AS c ON loan.account_id = c.client_id WHERE      c.gender = 'M',"SELECT      ((SUM(CASE WHEN strftime('%Y', date) = '1997' THEN amount ELSE 0 END) -       SUM(CASE WHEN strftime('%Y', date) = '1996' THEN amount ELSE 0 END)) /      SUM(CASE WHEN strftime('%Y', date) = '1996' THEN amount ELSE 0 END)) * 100 AS growth_rate FROM      loan JOIN      account ON loan.account_id = account.account_id JOIN      client ON account.account_id = client.account_id WHERE      client.gender = 'M'",0,0,0
List all carcinogenic molecules and their elements.,challenging,"SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",SELECT a.element FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label = '+'   Step 4: Query Review - All table/column references are correct - Join condition is valid - No aggregations or groupings - Query meets the requirement to list all carcinogenic molecules and their elements,"SELECT m.molecule_id, a.element FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+'   ### Step 4: Query Review - **Table/Column References**: All referenced columns (molecule_id, label, atom_id, element) exist in the schema. - **Join Conditions**: Correctly joins `molecule` and `atom` on `molecule_id`. - **Aggregations/Groupings**: None. - **Validation**: Confirms all carcinogenic molecules and their elements are listed.  Final SQLite Query: sql SELECT m.molecule_id, a.element FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' ","SELECT molecule.molecule_id, atom.element FROM molecule JOIN atom ON molecule.molecule_id = atom.molecule_id WHERE molecule.label = '+'    - Ensure all referenced columns exist in the schema    - Include proper joins based on identified relationships    - Apply necessary filters and aggregations  Query: SELECT molecule.molecule_id, atom.element  FROM molecule  JOIN atom ON molecule.molecule_id = atom.molecule_id  WHERE molecule.label = '+' ",0,0,0
What is the composition of element chlorine in percentage among the single bond molecules?,challenging,"SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T","SELECT      molecule.molecule_id,     DIVIDE(SUM(atom.element = 'cl'), COUNT(atom.atom_id)) AS percent FROM      molecule JOIN      bond ON molecule.molecule_id = bond.molecule_id JOIN      connected ON bond.bond_id = connected.bond_id JOIN      atom ON connected.atom_id = atom.atom_id WHERE      bond.bond_type = '-' GROUP BY      molecule.molecule_id","SELECT      molecule.molecule_id,      (SELECT COUNT(*)       FROM atom       WHERE atom.molecule_id = molecule.molecule_id AND atom.element = 'cl') AS cl_count,      (SELECT COUNT(*)       FROM atom       WHERE atom.molecule_id = molecule.molecule_id) AS total_atoms FROM      molecule JOIN      bond ON molecule.molecule_id = bond.molecule_id WHERE      bond.bond_type = '-' GROUP BY      molecule.molecule_id HAVING      total_atoms > 0 ORDER BY      molecule.molecule_id","SELECT      molecule.molecule_id,     DIVIDE(SUM(atom.element = 'cl'), COUNT(atom.atom_id)) AS percent FROM      atom JOIN      molecule ON atom.molecule_id = molecule.molecule_id JOIN      bond ON atom.molecule_id = bond.molecule_id JOIN      connected ON atom.atom_id = connected.atom_id WHERE      bond.bond_type = '-' GROUP BY      molecule.molecule_id",0,0,0
"Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",challenging,SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000,SELECT a.type FROM account a JOIN district d ON a.district_id = d.district_id WHERE a.account_id NOT IN (     SELECT l.account_id     FROM loan l ) AND d.A10 BETWEEN 8000 AND 9000   Step 4: Query Review - All table/column references are correct. - Join condition is valid. - No aggregations or groupings are required. - Filters are correctly applied to exclude accounts eligible for loans and to filter districts by average income.  Final SQLite Query: sql SELECT a.type FROM account a JOIN district d ON a.district_id = d.district_id WHERE a.account_id NOT IN (     SELECT l.account_id     FROM loan l ) AND d.A10 BETWEEN 8000 AND 9000,SELECT a.frequency FROM account a JOIN district d ON a.district_id = d.district_id WHERE a.district_id IN (     SELECT district_id     FROM district     WHERE A10 BETWEEN 8000 AND 9000 ) AND a.account_id NOT IN (     SELECT account_id     FROM loan     WHERE account_id = a.account_id ) AND a.type = 'OWNER',"SELECT a.type FROM account a JOIN district d ON a.district_id = d.district_id WHERE a.type != 'OWNER' AND d.A11 BETWEEN 8000 AND 9000   4. Query Review:    - Table/column references: a.type, a.district_id, d.A11    - Join condition: a.district_id = d.district_id    - Aggregation: Average income calculation is implicit in the WHERE clause    - Validation: Ensures accounts not owned by clients are listed, and only accounts in districts with average income between $8000 and $9000 are considered.",0,0,0
"Among the members who incurred expenses in more than one event, who paid the most amount?",challenging,SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1,"SELECT m.member_id, MAX(e.cost) AS max_expense FROM member m JOIN expense e ON m.member_id = e.link_to_member JOIN attendance a ON m.member_id = a.link_to_member WHERE a.link_to_event IN (     SELECT e.event_id     FROM event e     JOIN expense ex ON e.event_id = ex.link_to_event     GROUP BY e.event_id     HAVING COUNT(ex.expense_id) > 1 ) GROUP BY m.member_id ORDER BY max_expense DESC LIMIT 1",NULL,"SELECT      m.member_id,      SUM(e.cost) AS total_expense FROM      member m JOIN      expense e ON m.member_id = e.link_to_member JOIN      attendance a ON m.member_id = a.link_to_member GROUP BY      m.member_id HAVING      COUNT(DISTINCT a.link_to_event) > 1 ORDER BY      total_expense DESC LIMIT 1",0,0,0
"For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",challenging,"SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'","SELECT      ( (a.balance_date_A - a.balance_date_B) / a.balance_date_B ) * 100 AS increase_rate FROM      (         SELECT              a.account_id,             a.balance AS balance_date_A,             LAG(a.balance) OVER (PARTITION BY a.account_id ORDER BY t.date) AS balance_date_B         FROM              account a         JOIN              trans t ON a.account_id = t.account_id         WHERE              t.date = '1993-03-22'     ) a JOIN      (         SELECT              l.account_id,             l.date,             l.amount         FROM              loan l         WHERE              l.date = '1993-07-05'     ) l ON a.account_id = l.account_id JOIN      (         SELECT              a.account_id,             a.balance AS balance_date_A         FROM              account a         JOIN              trans t ON a.account_id = t.account_id         WHERE              t.date = '1998-12-27'     ) a2 ON a.account_id = a2.account_id",SELECT      (         (             (SELECT balance               FROM trans               WHERE account_id = (                  SELECT account_id                   FROM loan                   WHERE date = '1993-07-05'              )               AND date = '1998-12-27'             ) -              (SELECT balance               FROM trans               WHERE account_id = (                  SELECT account_id                   FROM loan                   WHERE date = '1993-07-05'              )               AND date = '1993-03-22'             )         ) /          (SELECT balance           FROM trans           WHERE account_id = (              SELECT account_id               FROM loan               WHERE date = '1993-07-05'          )           AND date = '1993-03-22'         )     ) * 100 AS rate_of_increase FROM trans LIMIT 1,SELECT      ((SUM(t1.balance) - SUM(t2.balance)) / SUM(t2.balance)) * 100 AS increase_rate FROM      client c JOIN      disp d ON c.client_id = d.client_id JOIN      account a ON d.account_id = a.account_id JOIN      trans t1 ON a.account_id = t1.account_id AND t1.date = '1998-12-27' JOIN      trans t2 ON a.account_id = t2.account_id AND t2.date = '1993-03-22' JOIN      loan l ON a.account_id = l.account_id WHERE      l.date = '1993-07-05'      AND c.client_id = (         SELECT              client_id         FROM              loan         WHERE              date = '1993-07-05'         ORDER BY              date         LIMIT 1     ),0,0,0
"Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",challenging,"SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'","SELECT      DIVIDE(MULTIPLY((SUM(preferred_foot = 'left')), 100), COUNT(player_fifa_api_id)) AS percentage_left_foot_players FROM      Player WHERE      YEAR(birthday) BETWEEN '1987' AND '1992'","SELECT      DIVIDE(MULTIPLY((SELECT COUNT(*) FROM Player WHERE preferred_foot = 'left' AND YEAR(birthday) BETWEEN '1987' AND '1992'), 100),      (SELECT COUNT(*) FROM Player WHERE YEAR(birthday) BETWEEN '1987' AND '1992')) AS percentage_left_foot_players FROM Player LIMIT 1","SELECT      DIVIDE(MULTIPLY((SELECT COUNT(*) FROM Player WHERE preferred_foot = 'left' AND YEAR(birthday) BETWEEN '1987' AND '1992'), 100),      (SELECT COUNT(*) FROM Player WHERE YEAR(birthday) BETWEEN '1987' AND '1992')) AS left_foot_preference_percentage FROM Player LIMIT 1",0,0,0
"List all the elements with double bond, consisted in molecule TR024.",challenging,SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '=',SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '=' AND a.molecule_id = 'TR024',SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '=' AND a.molecule_id = 'TR024',"SELECT DISTINCT atom.element FROM atom JOIN connected ON atom.atom_id = connected.atom_id JOIN bond ON connected.bond_id = bond.bond_id JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE bond.bond_type = '=' AND molecule.molecule_id = 'TR024' AND atom.element IN ('cl', 'c', 'h')",0,0,0
"At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",challenging,"SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.`date`) >= '2013' AND STRFTIME('%Y',t1.`date`) <= '2015' AND t1.sprint_speed >= 97","SELECT Player.player_api_id, (DATETIME() - Player.birthday) AS age    - FROM Player    - JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id    - WHERE Player_Attributes.sprint_speed >= 97 AND YEAR(Player_Attributes.date) BETWEEN 2013 AND 2015  4. Query Review:    - All table/column references are correct    - Join condition is valid    - Filter conditions are correctly applied    - Calculation for age is appropriate  Final SQLite Query: sql SELECT Player.player_api_id, (DATETIME() - Player.birthday) AS age FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE Player_Attributes.sprint_speed >= 97 AND YEAR(Player_Attributes.date) BETWEEN 2013 AND 2015","SELECT      FLOOR( (DATETIME('now') - Player.birthday) / 365.25 ) AS age,     AVG(Player_Attributes.sprint_speed) AS avg_sprint_speed FROM      Player JOIN      Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE      Player_Attributes.sprint_speed >= 97     AND YEAR(Player_Attributes.date) BETWEEN 2013 AND 2015 GROUP BY      age","SELECT      Player.player_name,      Player.birthday,      (DATETIME() - Player.birthday) AS age_at_present FROM      Player JOIN      Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE      Player_Attributes.sprint_speed >= 97      AND YEAR(Player_Attributes.date) BETWEEN 2013 AND 2015   4. Query Review:    - All table/column references are correct.    - Join condition is appropriate.    - Filters are correctly applied.    - Calculation for age at present is correctly implemented.  Generated SQL Query: sql SELECT      Player.player_name,      Player.birthday,      (DATETIME() - Player.birthday) AS age_at_present FROM      Player JOIN      Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE      Player_Attributes.sprint_speed >= 97      AND YEAR(Player_Attributes.date) BETWEEN 2013 AND 2015",0,0,0
"Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",challenging,SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id,SELECT      (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) -      (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) AS difference_in_number_of_superheroes FROM superhero LIMIT 1,"SELECT      (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) AS Marvel_Count,     (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) AS DC_Count,     ((SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) -       (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'DC Comics'))) AS Difference FROM superhero LIMIT 1","SELECT      publisher_name,     COUNT(*) AS superhero_count,     (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) -      (SELECT COUNT(*) FROM superhero WHERE publisher_id IN (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) AS difference FROM      superhero JOIN      publisher ON superhero.publisher_id = publisher.id GROUP BY      publisher_name HAVING      publisher_name IN ('Marvel Comics', 'DC Comics')",1,0,0
How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?,challenging,"SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539","SELECT      COUNT(*) AS statement_requests,     SUM(amount) AS total_debit FROM      trans WHERE      account_id = 3 AND      type = 'VYDAJ' AND      operation = 'PREVOD NA UCET'","SELECT      COUNT(*) AS statement_requests,     SUM(amount) AS total_debited FROM      trans WHERE      account_id = 3 AND type = 'VYBER' UNION ALL SELECT      COUNT(*) AS statement_requests,     SUM(amount) AS total_debited FROM      order WHERE      account_id = 3   Step 4: Query Review - All table/column references checked and correct - Join conditions not applicable here as we're directly querying from the tables - Aggregations and groupings applied correctly - Query validates against requirements","SELECT      a.date,     COUNT(t.trans_id) AS transaction_count FROM      account a JOIN      trans t ON a.account_id = t.account_id WHERE      a.account_id = 3     AND t.type = 'VYBER' GROUP BY      a.date ORDER BY      a.date",0,0,0
What is the element of toxicology for the atom with the ID of TR000_1?,challenging,SELECT T.element FROM atom AS T WHERE T.atom_id = 'TR000_1',SELECT a.element FROM atom a WHERE a.atom_id = 'TR000_1',SELECT atom.element FROM atom WHERE atom.atom_id = 'TR000_1',SELECT element FROM atom WHERE atom_id = 'TR000_1',1,1,1
"From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",challenging,"SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",SELECT      (COUNT(DISTINCT drivers.driverId) FILTER (WHERE drivers.dob < '1985-01-01' AND lapTimes.laps > 50) * 100.0 / COUNT(DISTINCT drivers.driverId) FILTER (WHERE races.year BETWEEN 2000 AND 2005)) AS percentage FROM      drivers JOIN      lapTimes ON drivers.driverId = lapTimes.driverId JOIN      races ON lapTimes.raceId = races.raceId WHERE      races.year BETWEEN 2000 AND 2005,SELECT      (COUNT(DISTINCT ds.driverId) FILTER (WHERE ds.dob < '1985-01-01' AND lt.laps > 50) * 100.0 /       COUNT(DISTINCT ds.driverId) FILTER (WHERE ds.dob BETWEEN '2000-01-01' AND '2005-12-31')) AS percentage FROM      drivers ds JOIN      lapTimes lt ON ds.driverId = lt.driverId WHERE      lt.raceId IN (SELECT raceId FROM races WHERE year BETWEEN 2000 AND 2005),"SELECT      (COUNT(DISTINCT l.driverId) * 1.0 / COUNT(DISTINCT d.driverId)) * 100 AS percentage FROM      drivers d JOIN      results r ON d.driverId = r.driverId JOIN      races ra ON r.raceId = ra.raceId WHERE      d.dob < '1985-01-01'      AND ra.year BETWEEN 2000 AND 2005      AND r.laps > 50   ### Step 4: Query Review - **Table/Column References**: All referenced columns (`drivers.driverId`, `results.raceId`, `results.laps`, `races.year`, `drivers.dob`) exist in the schema. - **Join Conditions**: Correctly join `drivers` with `results` and `races` based on `driverId` and `raceId`. - **Filters and Aggregations**: Correctly applied filters for birth year and lap numbers. - **Calculations**: ",0,0,0
"List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",challenging,"SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'","SELECT      c_eye.colour AS eyes,     c_hair.colour AS hair,     c_skin.colour AS skin FROM      superhero AS s JOIN      colour AS c_eye ON s.eye_colour_id = c_eye.id JOIN      colour AS c_hair ON s.hair_colour_id = c_hair.id JOIN      colour AS c_skin ON s.skin_colour_id = c_skin.id WHERE      s.gender_id = (SELECT id FROM gender WHERE gender = 'Female')     AND s.publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics')   ","SELECT      c_eye.colour AS eyes,      c_hair.colour AS hair,      c_skin.colour AS skin FROM      superhero AS s JOIN      colour AS c_eye ON s.eye_colour_id = c_eye.id JOIN      colour AS c_hair ON s.hair_colour_id = c_hair.id JOIN      colour AS c_skin ON s.skin_colour_id = c_skin.id WHERE      s.gender_id = (SELECT id FROM gender WHERE gender = 'Female')     AND s.publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics') ","SELECT      colour.colour AS eye_colour,     colour.colour AS hair_colour,     colour.colour AS skin_colour FROM      superhero JOIN      gender ON superhero.gender_id = gender.id JOIN      colour ON superhero.eye_colour_id = colour.id JOIN      colour AS hair_colour ON superhero.hair_colour_id = hair_colour.id JOIN      colour AS skin_colour ON superhero.skin_colour_id = skin_colour.id JOIN      publisher ON superhero.publisher_id = publisher.id WHERE      gender.gender = 'Female'     AND publisher.publisher_name = 'Dark Horse Comics'   Query Review: - All table/column references are correct. - Join conditions are correct. - No aggregations or groupings. - Filters applied correctly. - Ended query with a semicolon.",0,0,0
